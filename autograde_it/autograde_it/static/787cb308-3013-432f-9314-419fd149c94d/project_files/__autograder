#!/usr/bin/python2.4
from game import Agent
from searchAgents import SearchAgent
from game import Actions
import pdb


from game import Directions
import search as searchGlobal

class DummySearchProblem(searchGlobal.SearchProblem):
  """
  A simple graph-search problem, in which the agent can move east and west,
  where moving east takes the agent directly to the goal at a high cost, and
  moving west takes him slowly to the goal at a low cost. In queue-based
  search algorithms, if the student incorrectly checks for goal states when
  producing successors, the agent will go east. If the student correctly
  checks for goal states only when a node is being dequeued/expanded, the
  agent will move west.
  """
  
  def __init__(self):
    self.startState = 1
    self.goal = 10
    

  def getStartState(self):
    return self.startState

  def isGoalState(self, state):
    return state == self.goal   
   
  def getSuccessors(self, state):
    successors = [ (self.goal, Directions.EAST, 100), (state+1, Directions.WEST, 1) ]
    return successors

  def getCostOfActions(self, actions):
    cost = 0
    for a in actions:
        if a == Directions.EAST:
            cost = cost + 100
        elif a == Directions.WEST:
            cost = cost + 1
        else:
            cost = cost + 1000000
    return cost
    
## code to handle timeouts
import signal
class TimeoutFunctionException(Exception):
    """Exception to raise on a timeout"""
    pass

class TimeoutFunction:

    def __init__(self, function, timeout):
        self.timeout = timeout
        self.function = function

    def handle_timeout(self, signum, frame):
        raise TimeoutFunctionException()

    def __call__(self, **args):
        old = signal.signal(signal.SIGALRM, self.handle_timeout)
        signal.alarm(self.timeout)
        try:
            result = self.function(**args)
        finally:
            signal.signal(signal.SIGALRM, old)
        signal.alarm(0)
        return result

# Grading script for search project

import sys,os

def getAgents(agentName):
  return ( getattr(searchAgentsSol, agentName), getattr(searchAgents, agentName) )

def getAlgs(algName):
  return ( getattr(search, algName), getattr(searchSol, algName) )

def getStartState(layoutName):
  s = pacman.GameState()
  lay = layout.getLayout(layoutName,3)
  s.initialize(lay, 0)
  return s

def getSolutionPaths(alg, prob):
  prob._visited, prob._visitedlist, prob._expanded = {}, [], 0
  solPaths=[alg(prob)]
  solNodes = [prob._expanded]
  prob._visited, prob._visitedlist, prob._expanded = {}, [], 0
  searchSol.REVERSE_PUSH = not searchSol.REVERSE_PUSH
  solPaths.append(alg(prob))
  solNodes.append(prob._expanded)
  return solPaths, solNodes
  
def testSearch(grades, name, alg, problem, leewayFactor = 1): 
  "Returns true if the student's alg is correct and within the leewayFactor of nodes expanded."
  if type(alg) == type(''):
    studentAlg, solAlg = getAlgs(alg)
  else:
    studentAlg, solAlg = alg
    
  patchExpansionExploit(problem)
  studentPath = getStudentPath(grades, name, studentAlg, problem)
  if studentPath == None: return False

  studentNodes = problem._secretKeyLol
  solPaths, solNodes = getSolutionPaths(solAlg, problem)

  if studentPath not in solPaths:
    grades.fail('%s returned the wrong solution' % name)
    for solPath in solPaths:
      print 'Solution: ' + str(solPath)
    print 'Proposed: ' + str(studentPath)
    return False
  
  minNodes, maxNodes = float(min(solNodes)), float(max(solNodes))
  if studentNodes / maxNodes <= leewayFactor:
    return True
  else:
    if abs(studentNodes - maxNodes) <= 1: return True
    grades.fail('Wrong number of nodes expanded for %s: %d vs %d. Are you expanding nodes twice?' % (name, studentNodes, maxNodes))
    return False

def getStudentPath(grades, name, alg, problem):
  "Returns the path generated by the student's alg"
  result = alg(problem)
  if type(result) != type([]):
    grades.fail('The result of %s must be a list.' % name )
    return None
  from game import Directions 
  dirs = Directions.LEFT.keys()
  if [el in dirs for el in result].count(False) != 0:
    grades.fail('Output of %s must be a list of actions from game.Directions' %name)
    return None
  return result
  
def getStatesFromPath(start, path):
  "Returns the list of states visited along the path"
  vis = [start]
  curr = start
  for a in path:
    x,y = curr
    dx, dy = Actions.directionToVector(a)
    curr = (int(x + dx), int(y + dy))
    vis.append(curr)
  return vis


def goalAtDequeue(alg):
  studentAlg, junk = getAlgs(alg)
  problem = DummySearchProblem()
  studentPath = getStudentPath(grades, alg, studentAlg, problem)
  return len(studentPath) == 9

def q1(grades):
  "Tests for question 1"
  
  lay = 'mediumMaze'
  alg = 'depthFirstSearch'
  
  #if not goalAtDequeue(alg):
  #  grades.addMessage("""
  #    <p>
  #    Suboptimality detected in DFS. on the following graph: <br/>
  #    A -- 1 --> B -- 1 --> C -- 1 --> D <br/>
  #    |                                ^ <br/>
  #    |                                | <br/>
  #    --------------- 10 --------------- <br/>
  #    You return [A, D]                  <br/>
  #    When the optimal path is [A,B,C,D] <br/>
  #    (A is the start state, D is the goal state) <br/>
  #    </p>
  #  """)
  #  return
  
  startState = getStartState(lay)
  problem = searchAgents.PositionSearchProblem(startState)  
  if testSearch(grades, alg, alg, problem): grades.assignFullCredit()

def q2(grades):
  "Tests for question 2"
  lay = 'mediumMaze'
  alg = 'breadthFirstSearch'
  
  startState = getStartState(lay)
  problem = searchAgents.PositionSearchProblem(startState)
  if testSearch(grades, alg, alg, problem): grades.assignFullCredit()   

def q3(grades):
  "Tests for question 3"
  lay = 'mediumMaze'
  alg = 'uniformCostSearch'
  
  
  startState = getStartState(lay)
  problemC = searchAgents.PositionSearchProblem(startState)
  problemE = searchAgents.PositionSearchProblem(startState, lambda pos: .5 ** pos[0])
  problemW = searchAgents.PositionSearchProblem(startState, lambda pos: 2 ** pos[0])
  
  searchStartState = getStartState('testSearch')
  searchProb = searchAgents.FoodSearchProblem(searchStartState)
  
  success = [testSearch(grades, alg, alg, problem, leewayFactor=1.1) for problem in [problemC, problemE, problemW]]
  success.append(testSearch(grades, alg, alg, searchProb, leewayFactor=2))
  grades.addPoints( success.count(True) / 2 )
  
  if grades.points[grades.currentQuestion] < 2:
    # No need to barrage the student with the DummyProblem corner case
    return
  
  
  if not goalAtDequeue(alg):
    grades.addMessage("""
<pre>
Suboptimality detected in UCS. on the following graph:
A -- 1 --> B -- 1 --> C -- 1 --> D
|                                ^
|                                |
--------------- 10 ---------------
You return [A, D]                 
When the optimal path is [A,B,C,D]
(A is the start state, D is the goal state)
</pre>
    """, raw=True)
    grades.assignZeroCredit()
    return  

def q4(grades):
  "Tests for question 4"
  lay = 'mediumMaze'
  name = "astar"
  
  
  startState = getStartState(lay)
  problem = searchAgents.PositionSearchProblem(startState)
  dist = searchAgents.manhattanHeuristic
  alg = (lambda x: search.astar(x, dist), lambda x: searchSol.astar(x, dist))
  if testSearch(grades, name, alg, problem, leewayFactor=1.1):
    grades.assignFullCredit()
  
  if grades.points[grades.currentQuestion] < 3:
    # No need to barrage the student with the DummyProblem corner case if they're already wrong
    return
  
  if not goalAtDequeue(name):
    grades.addMessage("""
<pre>
Suboptimality detected in A*. on the following graph:
A -- 1 --> B -- 1 --> C -- 1 --> D
|                                ^
|                                |
--------------- 10 ---------------
You return [A, D]                 
When the optimal path is [A,B,C,D]
(A is the start state, D is the goal state)
</pre>
    """, raw=True)
    grades.assignZeroCredit()
    return  

def q5(grades):
  "Tests CornersProblem"
  lay = 'tinyCorners'
  startState = getStartState(lay)
  studentProblem = searchAgents.CornersProblem(startState)
  solProblem = searchAgentsSol.CornersProblem(startState)
  
  studentResult = getStudentPath(grades, 'bfs', searchSol.bfs, studentProblem)
  correctResult = getStudentPath(grades, 'bfs', searchSol.bfs, solProblem)
  if len(studentResult) != len(correctResult): 
    grades.addMessage('Optimal path from student problem did not match the optimal path')
  else:
    visited = getStatesFromPath(startState.getPacmanPosition(), studentResult)
    top, right = startState.getWalls().height-2, startState.getWalls().width-2 
    corners = ((1,1), (1,top), (right, 1), (right, top))
    for corner in corners:
      if corner not in visited: grades.addMessage( 'Path missed corner ' + str(corner))
    if [c in visited for c in corners].count(True) == 4: grades.assignFullCredit()
  
def q6(grades):
  "Tests heuristic for CornersProblem"
  heuristic = searchAgents.cornersHeuristic
  for name, cost, layout in cornerTests:
     if not cornerAdmissible(layout, cost, heuristic):
       grades.addMessage('Heuristic failed admissibility test %s' % name)
       return
     else:
       print 'Passed admissibility test %s' % name
   
  nontrivial = False
  for name, cost, layout in cornerTests:
    nontrivial = nontrivial or cornerNontrivial(layout, cost, heuristic)
  
  if not nontrivial:
    grades.addMessage('Heuristic failed non-triviality test %s' % name)
    return
  else:
    print 'Passed non-triviality test %s' % name  
  
  lay = 'mediumCorners'
  gameState = getStartState(lay)
  problem = searchAgents.CornersProblem(gameState)
  if heuristic(problem.getStartState(), problem) > 106: 
    grades.addMessage('Heuristic failed admissibility test (mediumCorners)')
    return
     
  patchExpansionExploit(problem)
  path = searchSol.astar(problem, heuristic)
  cost = problem.getCostOfActions(path)
  if cost > 106:
    grades.addMessage('A* gave a non-optimal solution to mediumCorners; maybe not admissible!')
 
  thresholds = [2000, 1600, 1200]
  grades.addMessage("For mediumCorners, the A* agent expanded %d nodes" % problem._secretKeyLol)
  print 'Thresholds: ' + str(thresholds)
  for threshold in thresholds: 
    if problem._secretKeyLol < threshold:
      grades.addPoints(1)
    else:
      grades.addMessage("For mediumCorners, the A* agent failed to expand less than %d nodes, -1 point" % threshold)
  
  for name, cost, layout in cornerTests:
    if not cornerConsistencyA(layout, cost, heuristic):
      grades.addMessage('Heuristic failed consistency test %s-A' % name)
      grades.assignZeroCredit()
      return
    else:
      print 'Passed consistency test %s-A' % name
    if not cornerConsistencyB(layout, cost, heuristic):
      grades.addMessage('Heuristic failed consistency test %s-B' % name)
      grades.assignZeroCredit()
      return
    else:
      print 'Passed consistency test %s-B' % name
  
  
  for name, cost, layout in cornerTests:
    if not cornerPosH(layout, cost, heuristic):
      grades.addMessage('Heuristic failed (H > 0) test %s' % name)
      grades.addPoints(-1)
      return
    else:
      print 'Passed H > 0 %s' % name

  for name, cost, layout in cornerTests:
    if not cornerGoalH(layout, cost, heuristic):
      grades.addMessage('Heuristic failed H(goal) == 0 test %s' % name)
      grades.addPoints(-1)
      break
    else:
      print 'Passed H(goal) == 0 test %s' % name



def followAction(state, action, problem):
  for successor1, action1, cost1 in problem.getSuccessors(state):
    if action == action1: return successor1
  return None

def followPath(path, problem):
  state = problem.getStartState()
  states = [state]
  for action in path:
    state = followAction(state, action, problem)
    states.append(state)
  return states


# Checks that H is consistent throughout an instance of search
def cornerConsistencyB(layoutText, cost, heuristic):  

  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  path = searchSol.astar(problem, heuristic)
  states = followPath(path, problem)
  heuristics = []
  for state in states:
    heuristics.append(heuristic(state, problem))
  
  for i in range(0, len(heuristics)-1):
    h0 = heuristics[i]
    h1 = heuristics[i+1]
    if h0 - h1 > 1:
      return False
  
  return True


# Checks that H > 0 at the start state
def cornerNontrivial(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  startState = problem.getStartState()
  return heuristic(startState, problem) > 0


# Checks that H == 0 at the goal state
def cornerGoalH(layoutText, cost, heuristic):  
  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  path = searchSol.astar(problem, heuristic)
  states = followPath(path, problem)
  
  return heuristic(states[len(states)-1], problem) == 0


# Checks that H > 0 always
def cornerPosH(layoutText, cost, heuristic):  
  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  path = searchSol.astar(problem, heuristic)
  states = followPath(path, problem)
  heuristics = []
  for state in states:
    if heuristic(state, problem) < 0:
      return False
  return True


def cornerAdmissible(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  startState = problem.getStartState()
  return heuristic(startState, problem) <= cost

def cornerConsistencyA(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.CornersProblem(gameState)
  state = problem.getStartState()

  h0 = heuristic(state, problem)
  succs = problem.getSuccessors(state)
  for succ in succs:
    h1 = heuristic(succ[0], problem)
    if h0 - h1 > 1: return False
  return True

cornerTests = [('ct1', 8, ["%%%%%",
                           "%. .%",
                           "%   %",
                           "%   %",
                           "%.P.%",
                           "%%%%%"]),
                           
               ('ct2', 8, ["%%%%%",
                           "%. .%",
                           "%%% %",
                           "%P% %",
                           "%. .%",
                           "%%%%%"]),
                           
               ('ct3',28, ["%%%%%%%%",
                           "%.    .%",
                           "%   P  %",
                           "% %%%% %",
                           "% %    %",
                           "% % %%%%",
                           "%.%   .%",
                           "%%%%%%%%"])]

def patchExpansionExploit(problem):
    problem._getSuccessors = problem.getSuccessors
    problem._secretKeyLol = 0
    def patchedSuccessors(problem, state):
        problem._secretKeyLol += 1
        return problem._getSuccessors(state)
    problem.getSuccessors = lambda state: patchedSuccessors(problem, state)

def q7(grades):
  "Tests food search heuristic"
  heuristic = searchAgents.foodHeuristic

  for name, cost, layout in foodTests:
    if not foodAdmissible(layout, cost, heuristic):
      grades.addMessage('Heuristic failed admissibility test %s' % name)
      return
    else:
      print 'Passed admissibility test %s' % name

  lay = 'trickySearch'
  gameState = getStartState(lay)
  problem = searchAgents.FoodSearchProblem(gameState)

  # modify the getSuccessors function to prevent exploits on _expanded
  patchExpansionExploit(problem)

  if heuristic(problem.getStartState(), problem) > 60: 
    grades.addMessage('Heuristic failed admissibility test trickySearch')
    return
  
  path = searchSol.astar(problem, heuristic)
  cost = problem.getCostOfActions(path)
  if cost > 60:
    grades.addMessage('A* gave a non-optimal solution to trickySearch; maybe not admissible!')
    return
  
  nontrivial = False
  for name, cost, layout in foodTests:
    nontrivial = nontrivial or foodNontrivial(layout, cost, heuristic)
  
  if not nontrivial:
    grades.addMessage('Heuristic failed non-triviality test %s' % name)
    return
  else:
    print 'Passed non-triviality test %s' % name  
  
  
  thresholds = [15000, 12000, 9000, 7000]
  grades.addMessage("For trickySearch, the A* agent expanded %d nodes" % problem._secretKeyLol)
  print 'Thresholds: ' + str(thresholds)
  for threshold in thresholds: 
    if problem._secretKeyLol < threshold:
      grades.addPoints(1)
    else:
      grades.addMessage("For trickySearch, the A* agent failed to expand fewer than %d nodes, -1 point" % threshold)
      
  grades.addPoints(1)
  for name, cost, layout in foodTests:
    if not foodConsistency(layout, cost, heuristic):
      grades.addMessage('Heuristic failed consistency test %s' % name)
      grades.assignZeroCredit()
      return
    else:
      print 'Passed consistency test %s' % name  
  
  for name, cost, layout in foodTests:
    if not foodPosH(layout, cost, heuristic):
      grades.addMessage('Heuristic failed (H > 0) %s' % name)
      grades.addPoints(-1)
      return
    else:
      print 'Passed H > 0 %s' % name

  for name, cost, layout in doneTests:
    if not foodGoalH(layout, cost, heuristic):
      grades.addMessage('Heuristic failed H(goal) == 0 test %s' % name)
      grades.addPoints(-1)
      break
    else:
      print 'Passed H(goal) == 0 test %s' % name
  
  # for name, cost, layout in foodTests:
  #   if not foodConsistency(layout, cost, heuristic):
  #     grades.addMessage('Food heuristic failed consistency test %s' % name)
  #     grades.addPoints(-2)
  #     break
  #   else:
  #     print 'Passed consistency test %s' % name
  # 
  # for name, cost, layout in foodTests:
  #   if not foodPosH(layout, cost, heuristic):
  #     grades.addMessage('Food heuristic failed H > 0 %s' % name)
  #     grades.addPoints(-1)
  #     return
  #   else:
  #     print 'Passed H > 0 %s' % name
  # 
  # for name, cost, layout in doneTests:
  #   if not foodGoalH(layout, cost, heuristic):
  #     grades.addMessage('Food heuristic failed H(goal) == 0 test %s' % name)
  #     grades.addPoints(-1)
  #     break
  #   else:
  #     print 'Passed H(goal) == 0 test %s' % name



# Checks that H == 0 at the goal state
def foodGoalH(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.FoodSearchProblem(gameState)
  state = problem.getStartState()
  
  h0 = heuristic(state, problem)
  return h0 == 0

# Checks that H > 0 always
def foodPosH(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.FoodSearchProblem(gameState)
  state = problem.getStartState()

  h0 = heuristic(state, problem)
  if h0 < 0: return False
  succs = problem.getSuccessors(state)
  for succ in succs:
    h1 = heuristic(succ[0], problem)
    if h1 < 0: return False
  return True  


# # Checks that H is consistent throughout an instance of search
# def foodConsistencyB(layoutText, cost, heuristic):  
# 
#   gameState = pacman.GameState()
#   lay = layout.Layout(layoutText)
#   gameState.initialize(lay, 0)
#   problem = searchAgents.FoodSearchProblem(gameState)
#   path = searchSol.astar(problem, heuristic)
#   states = followPath(path, problem)
#   heuristics = []
#   for state in states:
#     heuristics.append(heuristic(state, problem))
#   
#   for i in range(0, len(heuristics)-1):
#     h0 = heuristics[i]
#     h1 = heuristics[i+1]
#     if h0 - h1 > 1:
#       return False
#   
#   return True
# 
# 
# # Checks that H == 0 at the goal state
# def foodGoalH(layoutText, cost, heuristic):  
#   
#   gameState = pacman.GameState()
#   lay = layout.Layout(layoutText)
#   gameState.initialize(lay, 0)
#   problem = searchAgents.FoodSearchProblem(gameState)
#   path = searchSol.astar(problem, heuristic)
#   states = followPath(path, problem)
#   return heuristic(states[len(state)], problem) == 0
#   
# 
# 
# # Checks that H > 0 always
# def foodPosH(layoutText, cost, heuristic):  
#   
#   gameState = pacman.GameState()
#   lay = layout.Layout(layoutText)
#   gameState.initialize(lay, 0)
#   problem = searchAgents.FoodSearchProblem(gameState)
#   path = searchSol.astar(problem, heuristic)
#   states = followPath(path, problem)
#   heuristics = []
#   for state in states:
#     if heuristic(state, problem) < 0:
#       return False
#   return True

# Checks that H > 0 at the start state
def foodNontrivial(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.FoodSearchProblem(gameState)
  startState = problem.getStartState()
  return heuristic(startState, problem) > 0

def foodConsistency(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.FoodSearchProblem(gameState)
  state = problem.getStartState()
  
  h0 = heuristic(state, problem)
  succs = problem.getSuccessors(state)
  for succ in succs:
    h1 = heuristic(succ[0], problem)
    if h0 - h1 > 1: return False
  return True

def foodAdmissible(layoutText, cost, heuristic):  
  gameState = pacman.GameState()
  lay = layout.Layout(layoutText)
  gameState.initialize(lay, 0)
  problem = searchAgents.FoodSearchProblem(gameState)
  startState = problem.getStartState()
  return heuristic(startState, problem) <= cost

doneTests = [
("Test 1", 0, [
  "%%%%%",
  "%   %",
  "%   %",
  "%   %",
  "%P  %",
  "%%%%%"]),
  
 ("Test 2", 0, [
  "%%%%%%%%%%%%%%%%%%%%%%%%",
  "%     P                %",
  "%%%%%%%%%%%%%%%%%%%%%%%%"]),     

("Test 3", 0, [
  "%%%%%%%",
  "%     %",
  "%  P  %",
  "%%%%%%%"]),

("Test 12", 0, [
  "%%%%%%",
  "%    %",
  "% %% %",
  "% %% %",
  "% P  %",
  "% %%%%",
  "%    %",
  "%%%%%%"])]

foodTests = [
("Test 7",11, [
  "%%%%%",
  "%...%",
  "%...%",
  "%...%",
  "%P..%",
  "%%%%%"]),

("Test 6", 5, [
  "%%%%%",
  "% ..%",
  "% . %",
  "% P %",
  "% . %",
  "%%%%%"]),

("Test 5", 7, [
  "%%%%%",
  "% ..%",
  "% . %",
  "% P %",
  "%   %",
  "% . %",
  "%%%%%"]),

("Test 4", 5, [
  "%%%%%",
  "%...%",
  "%   %",
  "%   %",
  "%P  %",
  "%%%%%"]),                    

("Test 3", 6, [
  "%%%%%",
  "%.. %",
  "% %.%",
  "%.%%%",
  "%P  %",
  "%%%%%"]),                    

("Test 2", 7, [
  "%%%%%",
  "% . %",
  "%   %",
  "% P %",
  "%   %",
  "%   %",
  "% . %",
  "%%%%%"]),                    


("Test 1", 8, [
  "%%%%%",
  "%.  %",
  "%   %",
  "%.P %",
  "%   %",
  "%   %",
  "%.  %",
  "%%%%%"]),                                       

("Test 8", 1, [
  "%%%%%",
  "% . %",
  "% P %",
  "%   %",
  "%   %",
  "%   %",
  "%   %",
  "%%%%%"]),    

("Test 9", 5, [
  "%%%%%",
  "% . %",
  "%   %",
  "%   %",
  "%   %",
  "% . %",
  "% P %",
  "%%%%%"]),    

("Test 10", 31, [
  "%%%%%%%%%%%",
  "% ....... %",
  "% %%%%%%. %",
  "% ....... %",
  "% .%%%%%% %",
  "% ....... %",
  "% %%%%%%. %",
  "% ....... %",
  "% P       %",
  "%%%%%%%%%%%"]),

("Test 11", 21, [
  "%%%%%%%%%%%%%%%%%%%%%%%%",
  "%.    P .       ..     %",
  "%%%%%%%%%%%%%%%%%%%%%%%%"]),     
("Test 13", 7, [
  "%%%%%%%",
  "%.   .%",
  "%  P  %",
  "%%%%%%%"]),

("Test 12", 16, [
  "%%%%%%",
  "%....%",
  "% %%.%",
  "% %%.%",
  "%.P .%",
  "%.%%%%",
  "%....%",
  "%%%%%%"])]  
  
def q8(grades):
  "Tests for approximate search"
  studentClosest = searchAgents.ClosestDotSearchAgent()
  solClosest = searchAgentsSol.ClosestDotSearchAgent()
  for name, cost, lines in foodTests:
    gameState = pacman.GameState()
    lay = layout.Layout(lines)
    gameState.initialize(lay, 0)
    sol = solClosest.findPathToClosestDot(gameState)
    stu = studentClosest.findPathToClosestDot(gameState)
    if len(sol) != len(stu):
      grades.addMessage('Closest dot not found in %s' % name)
      return
  grades.assignFullCredit()
  
def extra_old(grades):
  "Evaluates their mini-contest entry"
  starttime = time.time()
  try:
    games = pacman.runGames(** pacman.readCommand('-l bigSearch -p ApproximateSearchAgent -q'.split()))
    print '*** Total time: %d seconds.' % (time.time() - starttime)
    print '*** Number of total moves:', len(games[0].moveHistory)
  except:
    grades.addMessage('Extra credit threw an exception')

def extra(grades):
  "Evaluates their mini-contest entry but times-out after max_time seconds"
  max_time = 30
  starttime = time.time()
  try:
    timed_func = TimeoutFunction(pacman.runGames, max_time)
    try:
      games = timed_func(** pacman.readCommand('-l bigSearch -p ApproximateSearchAgent -q'.split()))
      extra_time = (time.time() - starttime)
      #if games[0].state.isWin():
      print '*** Total time: %d seconds.' % extra_time
      print '*** Number of total moves:', len(games[0].moveHistory)
      grades.addMessage('Extra credit run-time: %1.2f' %extra_time)
      grades.addMessage('Extra credit total moves %d' %len(games[0].moveHistory))
    except TimeoutFunctionException:
      grades.addMessage('Extra credit code is too slow')
  except:
    grades.addMessage('Extra credit threw an exception')
#######################################################################
# Error Hint Map
#######################################################################
ERROR_HINT_MAP = {
  'q1': {
    "<type 'exceptions.IndexError'>": """
      We noticed that your project threw an IndexError on q1.
      While many things may cause this, it may have been from
      assuming a certain number of successors from a state space
      or assuming a certain number of actions available from a given
      state. Try making your code more general (no hardcoded indices)
      and submit again!
    """
  },
  'q3': {
      "<type 'exceptions.AttributeError'>": """
        We noticed that your project threw an AttributeError on q3.
        While many things may cause this, it may have been from assuming
        a certain size or structure to the state space. For example, if you have
        a line of code assuming that the state is (x, y) and we run your code
        on a state space with (x, y, z), this error could be thrown. Try
        making your code more general and submit again!

    """
  }
}
     
#######################################################################

if __name__ == '__main__':
  if len(sys.argv) != 2: 
    print 'Usage: searchGrader.py [transcript]\nUse - for stdout.'
    sys.exit(2)
  if sys.argv[1] != '-': sys.stdout = file(sys.argv[1], 'w')
  import grading
  
  import pacman, time, layout, textDisplay
  textDisplay.SLEEP_TIME = 0
  textDisplay.DRAW_EVERY = 1000

  # Our code
  import solution.searchAgents as searchAgentsSol
  import solution.search as searchSol

  # Their code
  import searchAgents, search

  questions = [('q1', 2), ('q2', 1), ('q3', 2), ('q4', 3), ('q5', 2), ('q6', 3), ('q7', 5), ('q8', 2), ('extra', 0)]
  grades = grading.Grades('Project 1: Search', questions)
  grades.grade(sys.modules[__name__], exceptionMap = ERROR_HINT_MAP)
  sys.stdout.close()
